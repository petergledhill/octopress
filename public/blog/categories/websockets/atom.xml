<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Websockets | Peter Gledhill, Freelance Developer]]></title>
  <link href="http://www.peteg.eu/blog/categories/websockets/atom.xml" rel="self"/>
  <link href="http://www.peteg.eu/"/>
  <updated>2013-11-28T13:34:22+00:00</updated>
  <id>http://www.peteg.eu/</id>
  <author>
    <name><![CDATA[Peter Gledhill]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Basics of Multi-player in Node.js : Part 1]]></title>
    <link href="http://www.peteg.eu/blog/2013/11/28/basics-of-multiplayer-in-nodejs-your-movement/"/>
    <updated>2013-11-28T13:03:58+00:00</updated>
    <id>http://www.peteg.eu/blog/2013/11/28/basics-of-multiplayer-in-nodejs-your-movement</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>The challenge for multi-player gaming is to ensure that all players see the same game state at roughly the same time. The game must also be playable on a slow connection and cheating should not be trivial.</p>

<p>In many multi-player games this is achieved by having a server which all clients connect to. The server maintains the correct game state and updates all the clients to keep them in sync.  This is called a client with authoritative server model and is generally used for first person shooters (Real time strategy games often use a peer-to-peer model with the <a href="http://en.wikipedia.org/wiki/Lockstep_protocol">lockstep protocol</a>).</p>

<h3>Dumb client</h3>

<p>Doom was one of the first games to use this model and supported up to 4 players at once.  In Dooms networking model the client computers are dumb, the client feeds instructions to the server and the server responds with the new game state.</p>

<p>For example the player presses the right arrow, the instruction is sent to the server and the server sends back a message saying &lsquo;your position is now X,Y&rsquo;.  This method works well when the game is played over a local area network (LAN) as there is little delay between the client and the server.</p>

<p>Over the Internet this method doesn&rsquo;t work.  By the time the client sends the message to the server and receives back the new state several hundred milliseconds may have passed. This results in very jerky movement.</p>

<h2>Client-side prediction</h2>

<p>The solution to this is to calculate the result of the move both locally and on the server. When a key is pressed, the client calculates the result locally and updates the position immediately.  The move and the client result are then sent to the server.</p>

<p>The server recalculates the result and either acknowledges the clients good move or sends a correction.  This way the client can react immediately to input and the server can maintain an authoritative state &ndash; the best of both worlds.</p>

<blockquote><p>A move would be an action such as &lsquo;move right&rsquo;. In a 2D game the result of this move might be a new position like x:10, y:0.  It&rsquo;s important to note that the move is a relative action and the result is an absolute.</p></blockquote>

<p>There are a few things to mention with this model:</p>

<h3>Determinism</h3>

<p>The game logic must be <a href="http://en.wikipedia.org/wiki/Deterministic_system">deterministic</a>.  This means each time we put in the same input we must get the same result back; there can not be a random element to the logic. If there was a random element then the client and server would often disagree about the result and the client would constantly need correcting, and the client-side prediction would have no benefit.</p>

<h3>Snapping</h3>

<p>After the client sends a move to the server it will continue to generate new moves.  By the time the client receives a response from the server several hundred milliseconds will have past and the client will be receiving a correction / confirmation of a move which happened in the past.  In the case that a correction is required this causes a problem.  If we update to the servers position the client will appear to jump back in time or &lsquo;snap&rsquo; to a new location.</p>

<p>To get around this problem the client can store all the moves which are made, when a correction is made to a move in the past we can then replay all future moves.  This works because the moves a relative actions such as &lsquo;move left&rsquo; and so can be reapplied from the corrected position.</p>

<h2>Breakdown</h2>

<h3>On the client</h3>

<ol>
<li>On the update loop &ndash; your keypresses are captured and recorded as a &lsquo;move&rsquo;. e.g. &lsquo;move left&rsquo; .</li>
<li>The result of the move is calculated and the position of your avatar is updated.</li>
<li>The move is stored along with the time it was created.</li>
<li>The move is sent to the server along with the result of the move.</li>
</ol>


<h3>On the server</h3>

<ol>
<li>The server receives the move and immediately calculates the result of the move on the avatar.</li>
<li>The result is checked against the clients result.

<ol>
<li>If the results match then the server sends a message to the client to say the result was good.</li>
<li>If the server disagrees about the result then it informs the client of what the result should have been.</li>
</ol>
</li>
</ol>


<h3>Back on the client</h3>

<p>Note: While the server was calculating the result, the client will have generated new moves and which it will have sent to the server.</p>

<ol>
<li>If a good move is acknowledged then no action is required.</li>
<li>If a move is corrected then update the position based on the result from the server.  Any moves which have occurred since this corrected move must be calculated again on the client.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First steps into real time multi-player with node.js]]></title>
    <link href="http://www.peteg.eu/blog/2013/05/13/first-steps-into-real-time-multiplayer-with-node-dot-js/"/>
    <updated>2013-05-13T15:01:00+01:00</updated>
    <id>http://www.peteg.eu/blog/2013/05/13/first-steps-into-real-time-multiplayer-with-node-dot-js</id>
    <content type="html"><![CDATA[<h2>Tl;Dr</h2>

<p>In my spare time I&rsquo;ve been playing around with node.js and websockets to learn more about how multi-player games work.  This is still work in progress and very basic but for anyone interested it&rsquo;s at <a href="https://github.com/petergledhill/basic-realtime-multiplayer">https://github.com/petergledhill/basic-realtime-multiplayer</a>.</p>

<h2>Story mode</h2>

<p>I&rsquo;ve been wanting to write some serious javascript and am interested in how multi-player games work.</p>

<p>I was aware that they operate under an authoritative server model; the server is responsible for recording state of the game and then broadcasts it to the clients (this helps to prevent cheating).  However I had no idea how to implement this in practice.</p>

<p>I came across this <a href="http://buildnewgames.com/real-time-multiplayer/">article by Sven Bergstr√∂m</a> which was very helpful in explaining how it all works. It even comes with source code written in Javascript for node.js and the browser.</p>

<p>Looking at the source I decided I wasn&rsquo;t going to get my head around the intricacies by hacking at it.  So I decided to have a go at writing something similar from scratch.</p>

<p>The aim is to show the principles of multi-player gaming through code, it&rsquo;s not a game itself but I hope to fully document the code and write a proper post about what I&rsquo;ve learned in the near future.</p>
]]></content>
  </entry>
  
</feed>
